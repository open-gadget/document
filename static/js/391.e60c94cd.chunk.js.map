{"version":3,"file":"static/js/391.e60c94cd.chunk.js","mappings":"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","sources":["offline-settings/db.ts","offline-settings/mdn-worker.tsx"],"sourcesContent":["// WARNING - This file is duplicated at two locations:\n// - client/pwa/src/db.ts\n// - client/src/offline-settings/db.ts\n// Until we find a solution, keep both files in sync.\n\nimport Dexie from \"dexie\";\n\nexport interface Watched {\n  url: string;\n  title: string;\n  path: string;\n  status: string;\n}\n\nexport interface Notifications {\n  id: number;\n  title: string;\n  text: string;\n  url: string;\n  created: Date;\n  read: boolean;\n  starred: boolean;\n}\n\ninterface Parent {\n  uri: string;\n  title: string;\n}\n\nexport interface Collections {\n  id?: number;\n  url: string;\n  title: string;\n  parents?: Array<Parent>[];\n  notes?: string;\n  created: Date;\n}\n\nexport interface Whoami {\n  id?: number;\n  username: string;\n  is_authenticated: boolean;\n  email: string;\n  avatar_url: string;\n  is_subscriber: boolean;\n}\n\nexport enum ContentStatusPhase {\n  INITIAL = \"initial\",\n  IDLE = \"idle\",\n  DOWNLOAD = \"download\",\n  UNPACK = \"unpack\",\n  CLEAR = \"clear\",\n}\n\nexport interface LocalContentStatus {\n  version: string;\n  date: string;\n}\n\nexport interface RemoteContentStatus {\n  date: string;\n  latest: string;\n  updates: [string];\n}\n\nexport interface ContentStatus {\n  id?: number;\n  phase: ContentStatusPhase;\n  local: LocalContentStatus | null;\n  remote: RemoteContentStatus | null;\n  progress: number | null;\n  timestamp: Date;\n}\n\nexport class MDNOfflineDB extends Dexie {\n  // Declare implicit table properties.\n  // (just to inform Typescript. Instanciated by Dexie in stores() method)\n  whoami!: Dexie.Table<Whoami, number>; // number = type of the primkey\n  contentStatusHistory!: Dexie.Table<ContentStatus, number>;\n  collections!: Dexie.Table<Collections, string>;\n  watched!: Dexie.Table<Watched, String>;\n  notifications!: Dexie.Table<Notifications, number>;\n\n  constructor() {\n    super(\"MDNOfflineDB\");\n    this.version(1).stores({\n      whoami:\n        \"++, username, is_authenticated, email, avatar_url, is_subscriber\",\n      collections: \"url, title, created\",\n      watched: \"url, title, path\",\n      notifications: \"id, title, text, url, created, read, starred\",\n    });\n    this.version(2).stores({\n      contentStatusHistory: \"++id\",\n    });\n  }\n}\n\nconst offlineDb = new MDNOfflineDB();\n\nasync function getContentStatus(): Promise<ContentStatus> {\n  const current = await offlineDb.contentStatusHistory.toCollection().last();\n\n  return (\n    current || {\n      phase: ContentStatusPhase.INITIAL,\n      local: null,\n      remote: null,\n      progress: null,\n      timestamp: new Date(),\n    }\n  );\n}\n\nasync function patchContentStatus(\n  changes: Omit<Partial<ContentStatus>, \"id\" | \"timestamp\">\n) {\n  const db = offlineDb;\n  const table = db.contentStatusHistory;\n\n  await db.transaction(\"rw\", table, async () => {\n    const oldStatus = await getContentStatus();\n    const newStatus = {\n      ...oldStatus,\n      ...changes,\n      id: undefined,\n      timestamp: new Date(),\n    };\n\n    if (oldStatus.phase === ContentStatusPhase.INITIAL && !changes.phase) {\n      newStatus.phase = ContentStatusPhase.IDLE;\n    }\n\n    if (oldStatus.id && oldStatus.phase === newStatus.phase) {\n      await table.update(oldStatus.id, newStatus);\n    } else {\n      await table.add(newStatus);\n      // Keep latest entries for debugging.\n      await table.reverse().offset(100).delete();\n    }\n  });\n}\n\nexport { offlineDb, getContentStatus, patchContentStatus };\n","import { getContentStatus } from \"./db\";\n\nexport class SettingsData {\n  offline?: boolean;\n  preferOnline?: boolean;\n  autoUpdates?: boolean;\n\n  constructor() {\n    this.offline = false;\n    this.preferOnline = false;\n    this.autoUpdates = false;\n  }\n}\n\nexport class MDNWorker {\n  settings: SettingsData;\n  registered: boolean;\n  timeout?: ReturnType<typeof setTimeout> | null;\n  keepAlive: ReturnType<typeof setInterval> | null;\n\n  constructor() {\n    this.settings = this.offlineSettings();\n    this.registered = false;\n    this.timeout = null;\n    this.keepAlive = null;\n\n    if (this.settings.autoUpdates) {\n      this.autoUpdate();\n    }\n  }\n\n  autoUpdate() {\n    console.log(\"running auto update\");\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n      this.timeout = null;\n    }\n    this.update();\n    this.timeout = setTimeout(() => this.autoUpdate(), 60 * 60 * 1000);\n  }\n\n  async messageHandler(event) {\n    switch (event.data.type) {\n      case \"pong\":\n        console.log(\"pong\");\n        break;\n      default:\n        console.log(\"unknown message\");\n    }\n  }\n\n  controller(): ServiceWorker | null {\n    return navigator.serviceWorker.controller;\n  }\n\n  checkForUpdate(): void {\n    this.controller()?.postMessage({ type: \"checkForUpdate\" });\n  }\n\n  update() {\n    this.controller()?.postMessage({ type: \"update\" });\n  }\n\n  swName(onlineFirst: boolean | null | undefined = null) {\n    const onlineFirstSW = onlineFirst ?? this.settings.preferOnline ?? false;\n    return `/service-worker.js?preferOnline=${onlineFirstSW}`;\n  }\n\n  async enableServiceWorker(onlineFirst: boolean | null | undefined = null) {\n    if (\"serviceWorker\" in navigator) {\n      await navigator.serviceWorker.register(this.swName(onlineFirst), {\n        scope: \"/\",\n      });\n      this.registered = true;\n    }\n    registerMessageHandler();\n  }\n\n  async disableServiceWorker() {\n    if (\"serviceWorker\" in navigator) {\n      const registration = await navigator.serviceWorker.getRegistration();\n      await registration?.unregister();\n      this.registered = false;\n    }\n  }\n\n  toggleKeepAlive(keepAlive: boolean) {\n    if (this.keepAlive && !keepAlive) {\n      console.log(\"[worker] keepalive -> enabling\");\n      clearInterval(this.keepAlive);\n      this.keepAlive = null;\n    } else if (keepAlive && !this.keepAlive) {\n      console.log(\"[worker] keepalive -> disabling\");\n      this.keepAlive = setInterval(\n        () => this.controller()?.postMessage({ type: \"keepalive\" }),\n        10000\n      );\n    }\n  }\n\n  async status() {\n    return await getContentStatus();\n  }\n\n  offlineSettings(): SettingsData {\n    return (\n      JSON.parse(window.localStorage.getItem(\"MDNSettings\") || \"null\") ??\n      new SettingsData()\n    );\n  }\n\n  async setOfflineSettings(settingsData: SettingsData): Promise<SettingsData> {\n    const current = this.offlineSettings();\n\n    if (!current.offline && settingsData.offline && !this.registered) {\n      await this.enableServiceWorker(settingsData.preferOnline);\n    } else if (\n      \"preferOnline\" in settingsData &&\n      current.preferOnline !== settingsData.preferOnline\n    ) {\n      await this.disableServiceWorker();\n      await this.enableServiceWorker(settingsData.preferOnline);\n    }\n    if (current.offline && settingsData.offline === false) {\n      await this.disableServiceWorker();\n    }\n\n    if (settingsData.autoUpdates === false && this.timeout) {\n      clearTimeout(this.timeout);\n      this.timeout = null;\n    } else if (\n      settingsData.autoUpdates === true &&\n      current.autoUpdates === false\n    ) {\n      this.autoUpdate();\n    }\n\n    const settings = { ...current, ...settingsData };\n    window.localStorage.setItem(\"MDNSettings\", JSON.stringify(settings));\n    this.settings = settings;\n    return settings;\n  }\n  async clear() {\n    this.controller()?.postMessage({ type: \"clear\" });\n  }\n}\n\ndeclare global {\n  interface Window {\n    mdnWorker: MDNWorker;\n  }\n}\n\nexport function getMDNWorker(): MDNWorker {\n  if (!window.mdnWorker) {\n    window.mdnWorker = new MDNWorker();\n  }\n  return window.mdnWorker;\n}\n\nconst mdnWorker = getMDNWorker();\n\nfunction registerMessageHandler() {\n  navigator.serviceWorker.addEventListener(\"message\", mdnWorker.messageHandler);\n}\n\nif (mdnWorker.settings.offline) {\n  mdnWorker.enableServiceWorker(mdnWorker.settings.preferOnline);\n}\n"],"names":["ContentStatusPhase","offlineDb","whoami","contentStatusHistory","collections","watched","notifications","version","stores","Dexie","getContentStatus","toCollection","last","current","phase","INITIAL","local","remote","progress","timestamp","Date","SettingsData","offline","preferOnline","autoUpdates","this","MDNWorker","settings","registered","timeout","keepAlive","offlineSettings","autoUpdate","console","log","clearTimeout","update","setTimeout","event","data","type","navigator","serviceWorker","controller","postMessage","onlineFirst","onlineFirstSW","register","swName","scope","registerMessageHandler","getRegistration","registration","unregister","clearInterval","setInterval","JSON","parse","window","localStorage","getItem","settingsData","enableServiceWorker","disableServiceWorker","setItem","stringify","getMDNWorker","mdnWorker","addEventListener","messageHandler"],"sourceRoot":""}