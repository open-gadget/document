{"version":3,"file":"static/js/68.7673ce03.chunk.js","mappings":"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","sources":["../../node_modules/rough-notation/lib/rough-notation.esm.js","../../node_modules/diff/lib/index.mjs"],"sourcesContent":["const t=\"http://www.w3.org/2000/svg\";class e{constructor(t){this.seed=t}next(){return this.seed?(2**31-1&(this.seed=Math.imul(48271,this.seed)))/2**31:Math.random()}}function s(t,e,s,i,n){return{type:\"path\",ops:c(t,e,s,i,n)}}function i(t,e,i){const n=(t||[]).length;if(n>2){const s=[];for(let e=0;e<n-1;e++)s.push(...c(t[e][0],t[e][1],t[e+1][0],t[e+1][1],i));return e&&s.push(...c(t[n-1][0],t[n-1][1],t[0][0],t[0][1],i)),{type:\"path\",ops:s}}return 2===n?s(t[0][0],t[0][1],t[1][0],t[1][1],i):{type:\"path\",ops:[]}}function n(t,e,s,n,o){return function(t,e){return i(t,!0,e)}([[t,e],[t+s,e],[t+s,e+n],[t,e+n]],o)}function o(t,e,s,i,n){return function(t,e,s,i){const[n,o]=l(i.increment,t,e,i.rx,i.ry,1,i.increment*h(.1,h(.4,1,s),s),s);let r=f(n,null,s);if(!s.disableMultiStroke){const[n]=l(i.increment,t,e,i.rx,i.ry,1.5,0,s),o=f(n,null,s);r=r.concat(o)}return{estimatedPoints:o,opset:{type:\"path\",ops:r}}}(t,e,n,function(t,e,s){const i=Math.sqrt(2*Math.PI*Math.sqrt((Math.pow(t/2,2)+Math.pow(e/2,2))/2)),n=Math.max(s.curveStepCount,s.curveStepCount/Math.sqrt(200)*i),o=2*Math.PI/n;let r=Math.abs(t/2),h=Math.abs(e/2);const c=1-s.curveFitting;return r+=a(r*c,s),h+=a(h*c,s),{increment:o,rx:r,ry:h}}(s,i,n)).opset}function r(t){return t.randomizer||(t.randomizer=new e(t.seed||0)),t.randomizer.next()}function h(t,e,s,i=1){return s.roughness*i*(r(s)*(e-t)+t)}function a(t,e,s=1){return h(-t,t,e,s)}function c(t,e,s,i,n,o=!1){const r=o?n.disableMultiStrokeFill:n.disableMultiStroke,h=u(t,e,s,i,n,!0,!1);if(r)return h;const a=u(t,e,s,i,n,!0,!0);return h.concat(a)}function u(t,e,s,i,n,o,h){const c=Math.pow(t-s,2)+Math.pow(e-i,2),u=Math.sqrt(c);let f=1;f=u<200?1:u>500?.4:-.0016668*u+1.233334;let l=n.maxRandomnessOffset||0;l*l*100>c&&(l=u/10);const g=l/2,d=.2+.2*r(n);let p=n.bowing*n.maxRandomnessOffset*(i-e)/200,_=n.bowing*n.maxRandomnessOffset*(t-s)/200;p=a(p,n,f),_=a(_,n,f);const m=[],w=()=>a(g,n,f),v=()=>a(l,n,f);return o&&(h?m.push({op:\"move\",data:[t+w(),e+w()]}):m.push({op:\"move\",data:[t+a(l,n,f),e+a(l,n,f)]})),h?m.push({op:\"bcurveTo\",data:[p+t+(s-t)*d+w(),_+e+(i-e)*d+w(),p+t+2*(s-t)*d+w(),_+e+2*(i-e)*d+w(),s+w(),i+w()]}):m.push({op:\"bcurveTo\",data:[p+t+(s-t)*d+v(),_+e+(i-e)*d+v(),p+t+2*(s-t)*d+v(),_+e+2*(i-e)*d+v(),s+v(),i+v()]}),m}function f(t,e,s){const i=t.length,n=[];if(i>3){const o=[],r=1-s.curveTightness;n.push({op:\"move\",data:[t[1][0],t[1][1]]});for(let e=1;e+2<i;e++){const s=t[e];o[0]=[s[0],s[1]],o[1]=[s[0]+(r*t[e+1][0]-r*t[e-1][0])/6,s[1]+(r*t[e+1][1]-r*t[e-1][1])/6],o[2]=[t[e+1][0]+(r*t[e][0]-r*t[e+2][0])/6,t[e+1][1]+(r*t[e][1]-r*t[e+2][1])/6],o[3]=[t[e+1][0],t[e+1][1]],n.push({op:\"bcurveTo\",data:[o[1][0],o[1][1],o[2][0],o[2][1],o[3][0],o[3][1]]})}if(e&&2===e.length){const t=s.maxRandomnessOffset;n.push({op:\"lineTo\",data:[e[0]+a(t,s),e[1]+a(t,s)]})}}else 3===i?(n.push({op:\"move\",data:[t[1][0],t[1][1]]}),n.push({op:\"bcurveTo\",data:[t[1][0],t[1][1],t[2][0],t[2][1],t[2][0],t[2][1]]})):2===i&&n.push(...c(t[0][0],t[0][1],t[1][0],t[1][1],s));return n}function l(t,e,s,i,n,o,r,h){const c=[],u=[],f=a(.5,h)-Math.PI/2;u.push([a(o,h)+e+.9*i*Math.cos(f-t),a(o,h)+s+.9*n*Math.sin(f-t)]);for(let r=f;r<2*Math.PI+f-.01;r+=t){const t=[a(o,h)+e+i*Math.cos(r),a(o,h)+s+n*Math.sin(r)];c.push(t),u.push(t)}return u.push([a(o,h)+e+i*Math.cos(f+2*Math.PI+.5*r),a(o,h)+s+n*Math.sin(f+2*Math.PI+.5*r)]),u.push([a(o,h)+e+.98*i*Math.cos(f+r),a(o,h)+s+.98*n*Math.sin(f+r)]),u.push([a(o,h)+e+.9*i*Math.cos(f+.5*r),a(o,h)+s+.9*n*Math.sin(f+.5*r)]),[u,c]}function g(t,e){return{maxRandomnessOffset:2,roughness:\"highlight\"===t?3:1.5,bowing:1,stroke:\"#000\",strokeWidth:1.5,curveTightness:0,curveFitting:.95,curveStepCount:9,fillStyle:\"hachure\",fillWeight:-1,hachureAngle:-41,hachureGap:-1,dashOffset:-1,dashGap:-1,zigzagOffset:-1,combineNestedSvgPaths:!1,disableMultiStroke:\"double\"!==t,disableMultiStrokeFill:!1,seed:e}}function d(e,r,h,a,c,u){const f=[];let l=h.strokeWidth||2;const d=function(t){const e=t.padding;if(e||0===e){if(\"number\"==typeof e)return[e,e,e,e];if(Array.isArray(e)){const t=e;if(t.length)switch(t.length){case 4:return[...t];case 1:return[t[0],t[0],t[0],t[0]];case 2:return[...t,...t];case 3:return[...t,t[1]];default:return[t[0],t[1],t[2],t[3]]}}}return[5,5,5,5]}(h),p=void 0===h.animate||!!h.animate,_=h.iterations||2,m=h.rtl?1:0,w=g(\"single\",u);switch(h.type){case\"underline\":{const t=r.y+r.h+d[2];for(let e=m;e<_+m;e++)e%2?f.push(s(r.x+r.w,t,r.x,t,w)):f.push(s(r.x,t,r.x+r.w,t,w));break}case\"strike-through\":{const t=r.y+r.h/2;for(let e=m;e<_+m;e++)e%2?f.push(s(r.x+r.w,t,r.x,t,w)):f.push(s(r.x,t,r.x+r.w,t,w));break}case\"box\":{const t=r.x-d[3],e=r.y-d[0],s=r.w+(d[1]+d[3]),i=r.h+(d[0]+d[2]);for(let o=0;o<_;o++)f.push(n(t,e,s,i,w));break}case\"bracket\":{const t=Array.isArray(h.brackets)?h.brackets:h.brackets?[h.brackets]:[\"right\"],e=r.x-2*d[3],s=r.x+r.w+2*d[1],n=r.y-2*d[0],o=r.y+r.h+2*d[2];for(const h of t){let t;switch(h){case\"bottom\":t=[[e,r.y+r.h],[e,o],[s,o],[s,r.y+r.h]];break;case\"top\":t=[[e,r.y],[e,n],[s,n],[s,r.y]];break;case\"left\":t=[[r.x,n],[e,n],[e,o],[r.x,o]];break;case\"right\":t=[[r.x+r.w,n],[s,n],[s,o],[r.x+r.w,o]]}t&&f.push(i(t,!1,w))}break}case\"crossed-off\":{const t=r.x,e=r.y,i=t+r.w,n=e+r.h;for(let o=m;o<_+m;o++)o%2?f.push(s(i,n,t,e,w)):f.push(s(t,e,i,n,w));for(let o=m;o<_+m;o++)o%2?f.push(s(t,n,i,e,w)):f.push(s(i,e,t,n,w));break}case\"circle\":{const t=g(\"double\",u),e=r.w+(d[1]+d[3]),s=r.h+(d[0]+d[2]),i=r.x-d[3]+e/2,n=r.y-d[0]+s/2,h=Math.floor(_/2),a=_-2*h;for(let r=0;r<h;r++)f.push(o(i,n,e,s,t));for(let t=0;t<a;t++)f.push(o(i,n,e,s,w));break}case\"highlight\":{const t=g(\"highlight\",u);l=.95*r.h;const e=r.y+r.h/2;for(let i=m;i<_+m;i++)i%2?f.push(s(r.x+r.w,e,r.x,e,t)):f.push(s(r.x,e,r.x+r.w,e,t));break}}if(f.length){const s=function(t){const e=[];for(const s of t){let t=\"\";for(const i of s.ops){const s=i.data;switch(i.op){case\"move\":t.trim()&&e.push(t.trim()),t=`M${s[0]} ${s[1]} `;break;case\"bcurveTo\":t+=`C${s[0]} ${s[1]}, ${s[2]} ${s[3]}, ${s[4]} ${s[5]} `;break;case\"lineTo\":t+=`L${s[0]} ${s[1]} `}}t.trim()&&e.push(t.trim())}return e}(f),i=[],n=[];let o=0;const r=(t,e,s)=>t.setAttribute(e,s);for(const a of s){const s=document.createElementNS(t,\"path\");if(r(s,\"d\",a),r(s,\"fill\",\"none\"),r(s,\"stroke\",h.color||\"currentColor\"),r(s,\"stroke-width\",\"\"+l),p){const t=s.getTotalLength();i.push(t),o+=t}e.appendChild(s),n.push(s)}if(p){let t=0;for(let e=0;e<n.length;e++){const s=n[e],r=i[e],h=o?c*(r/o):0,u=a+t,f=s.style;f.strokeDashoffset=\"\"+r,f.strokeDasharray=\"\"+r,f.animation=`rough-notation-dash ${h}ms ease-out ${u}ms forwards`,t+=h}}}}class p{constructor(t,e){this._state=\"unattached\",this._resizing=!1,this._seed=Math.floor(Math.random()*2**31),this._lastSizes=[],this._animationDelay=0,this._resizeListener=()=>{this._resizing||(this._resizing=!0,setTimeout(()=>{this._resizing=!1,\"showing\"===this._state&&this.haveRectsChanged()&&this.show()},400))},this._e=t,this._config=JSON.parse(JSON.stringify(e)),this.attach()}get animate(){return this._config.animate}set animate(t){this._config.animate=t}get animationDuration(){return this._config.animationDuration}set animationDuration(t){this._config.animationDuration=t}get iterations(){return this._config.iterations}set iterations(t){this._config.iterations=t}get color(){return this._config.color}set color(t){this._config.color!==t&&(this._config.color=t,this.refresh())}get strokeWidth(){return this._config.strokeWidth}set strokeWidth(t){this._config.strokeWidth!==t&&(this._config.strokeWidth=t,this.refresh())}get padding(){return this._config.padding}set padding(t){this._config.padding!==t&&(this._config.padding=t,this.refresh())}attach(){if(\"unattached\"===this._state&&this._e.parentElement){!function(){if(!window.__rno_kf_s){const t=window.__rno_kf_s=document.createElement(\"style\");t.textContent=\"@keyframes rough-notation-dash { to { stroke-dashoffset: 0; } }\",document.head.appendChild(t)}}();const e=this._svg=document.createElementNS(t,\"svg\");e.setAttribute(\"class\",\"rough-annotation\");const s=e.style;s.position=\"absolute\",s.top=\"0\",s.left=\"0\",s.overflow=\"visible\",s.pointerEvents=\"none\",s.width=\"100px\",s.height=\"100px\";const i=\"highlight\"===this._config.type;if(this._e.insertAdjacentElement(i?\"beforebegin\":\"afterend\",e),this._state=\"not-showing\",i){const t=window.getComputedStyle(this._e).position;(!t||\"static\"===t)&&(this._e.style.position=\"relative\")}this.attachListeners()}}detachListeners(){window.removeEventListener(\"resize\",this._resizeListener),this._ro&&this._ro.unobserve(this._e)}attachListeners(){this.detachListeners(),window.addEventListener(\"resize\",this._resizeListener,{passive:!0}),!this._ro&&\"ResizeObserver\"in window&&(this._ro=new window.ResizeObserver(t=>{for(const e of t)e.contentRect&&this._resizeListener()})),this._ro&&this._ro.observe(this._e)}haveRectsChanged(){if(this._lastSizes.length){const t=this.rects();if(t.length!==this._lastSizes.length)return!0;for(let e=0;e<t.length;e++)if(!this.isSameRect(t[e],this._lastSizes[e]))return!0}return!1}isSameRect(t,e){const s=(t,e)=>Math.round(t)===Math.round(e);return s(t.x,e.x)&&s(t.y,e.y)&&s(t.w,e.w)&&s(t.h,e.h)}isShowing(){return\"not-showing\"!==this._state}refresh(){this.isShowing()&&!this.pendingRefresh&&(this.pendingRefresh=Promise.resolve().then(()=>{this.isShowing()&&this.show(),delete this.pendingRefresh}))}show(){switch(this._state){case\"unattached\":break;case\"showing\":this.hide(),this._svg&&this.render(this._svg,!0);break;case\"not-showing\":this.attach(),this._svg&&this.render(this._svg,!1)}}hide(){if(this._svg)for(;this._svg.lastChild;)this._svg.removeChild(this._svg.lastChild);this._state=\"not-showing\"}remove(){this._svg&&this._svg.parentElement&&this._svg.parentElement.removeChild(this._svg),this._svg=void 0,this._state=\"unattached\",this.detachListeners()}render(t,e){let s=this._config;e&&(s=JSON.parse(JSON.stringify(this._config)),s.animate=!1);const i=this.rects();let n=0;i.forEach(t=>n+=t.w);const o=s.animationDuration||800;let r=0;for(let e=0;e<i.length;e++){const h=o*(i[e].w/n);d(t,i[e],s,r+this._animationDelay,h,this._seed),r+=h}this._lastSizes=i,this._state=\"showing\"}rects(){const t=[];if(this._svg)if(this._config.multiline){const e=this._e.getClientRects();for(let s=0;s<e.length;s++)t.push(this.svgRect(this._svg,e[s]))}else t.push(this.svgRect(this._svg,this._e.getBoundingClientRect()));return t}svgRect(t,e){const s=t.getBoundingClientRect(),i=e;return{x:(i.x||i.left)-(s.x||s.left),y:(i.y||i.top)-(s.y||s.top),w:i.width,h:i.height}}}function _(t,e){return new p(t,e)}function m(t){let e=0;for(const s of t){const t=s;t._animationDelay=e;e+=0===t.animationDuration?0:t.animationDuration||800}const s=[...t];return{show(){for(const t of s)t.show()},hide(){for(const t of s)t.hide()}}}export{_ as annotate,m as annotationGroup};\n","function Diff() {}\nDiff.prototype = {\n  diff: function diff(oldString, newString) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var callback = options.callback;\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    this.options = options;\n    var self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function () {\n          callback(undefined, value);\n        }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    } // Allow subclasses to massage the input prior to running\n\n\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n    var newLen = newString.length,\n        oldLen = oldString.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n\n    if (options.maxEditLength) {\n      maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n    }\n\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return done([{\n        value: this.join(newString),\n        count: newString.length\n      }]);\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath = void 0;\n\n        var addPath = bestPath[diagonalPath - 1],\n            removePath = bestPath[diagonalPath + 1],\n            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen,\n            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced, or until the edit length exceeds options.maxEditLength (if given),\n    // in which case it will return undefined.\n\n\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          if (editLength > maxEditLength) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength) {\n        var ret = execEditLength();\n\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n  pushComponent: function pushComponent(components, added, removed) {\n    var last = components[components.length - 1];\n\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n    var newLen = newString.length,\n        oldLen = oldString.length,\n        newPos = basePath.newPos,\n        oldPos = newPos - diagonalPath,\n        commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  equals: function equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n    }\n  },\n  removeEmpty: function removeEmpty(array) {\n    var ret = [];\n\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n\n    return ret;\n  },\n  castInput: function castInput(value) {\n    return value;\n  },\n  tokenize: function tokenize(value) {\n    return value.split('');\n  },\n  join: function join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n  var componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n\n      if (componentPos && components[componentPos - 1].added) {\n        var tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  } // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n\n\n  var lastComponent = components[componentLen - 1];\n\n  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}\n\nvar characterDiff = new Diff();\nfunction diffChars(oldStr, newStr, options) {\n  return characterDiff.diff(oldStr, newStr, options);\n}\n\nfunction generateOptions(options, defaults) {\n  if (typeof options === 'function') {\n    defaults.callback = options;\n  } else if (options) {\n    for (var name in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(name)) {\n        defaults[name] = options[name];\n      }\n    }\n  }\n\n  return defaults;\n}\n\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\n\nvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\nvar reWhitespace = /\\S/;\nvar wordDiff = new Diff();\n\nwordDiff.equals = function (left, right) {\n  if (this.options.ignoreCase) {\n    left = left.toLowerCase();\n    right = right.toLowerCase();\n  }\n\n  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n};\n\nwordDiff.tokenize = function (value) {\n  // All whitespace symbols except newline group into one token, each newline - in separate token\n  var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\n  for (var i = 0; i < tokens.length - 1; i++) {\n    // If we have an empty string in the next field and we have only word chars before and after, merge\n    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n      tokens[i] += tokens[i + 2];\n      tokens.splice(i + 1, 2);\n      i--;\n    }\n  }\n\n  return tokens;\n};\n\nfunction diffWords(oldStr, newStr, options) {\n  options = generateOptions(options, {\n    ignoreWhitespace: true\n  });\n  return wordDiff.diff(oldStr, newStr, options);\n}\nfunction diffWordsWithSpace(oldStr, newStr, options) {\n  return wordDiff.diff(oldStr, newStr, options);\n}\n\nvar lineDiff = new Diff();\n\nlineDiff.tokenize = function (value) {\n  var retLines = [],\n      linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  } // Merge the content and line separators into single tokens\n\n\n  for (var i = 0; i < linesAndNewlines.length; i++) {\n    var line = linesAndNewlines[i];\n\n    if (i % 2 && !this.options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      if (this.options.ignoreWhitespace) {\n        line = line.trim();\n      }\n\n      retLines.push(line);\n    }\n  }\n\n  return retLines;\n};\n\nfunction diffLines(oldStr, newStr, callback) {\n  return lineDiff.diff(oldStr, newStr, callback);\n}\nfunction diffTrimmedLines(oldStr, newStr, callback) {\n  var options = generateOptions(callback, {\n    ignoreWhitespace: true\n  });\n  return lineDiff.diff(oldStr, newStr, options);\n}\n\nvar sentenceDiff = new Diff();\n\nsentenceDiff.tokenize = function (value) {\n  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\n\nfunction diffSentences(oldStr, newStr, callback) {\n  return sentenceDiff.diff(oldStr, newStr, callback);\n}\n\nvar cssDiff = new Diff();\n\ncssDiff.tokenize = function (value) {\n  return value.split(/([{}:;,]|\\s+)/);\n};\n\nfunction diffCss(oldStr, newStr, callback) {\n  return cssDiff.diff(oldStr, newStr, callback);\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar objectPrototypeToString = Object.prototype.toString;\nvar jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\njsonDiff.useLongestToken = true;\njsonDiff.tokenize = lineDiff.tokenize;\n\njsonDiff.castInput = function (value) {\n  var _this$options = this.options,\n      undefinedReplacement = _this$options.undefinedReplacement,\n      _this$options$stringi = _this$options.stringifyReplacer,\n      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {\n    return typeof v === 'undefined' ? undefinedReplacement : v;\n  } : _this$options$stringi;\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\n\njsonDiff.equals = function (left, right) {\n  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n};\n\nfunction diffJson(oldObj, newObj, options) {\n  return jsonDiff.diff(oldObj, newObj, options);\n} // This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\nfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n\n  var i;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  var canonicalizedObj;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if (_typeof(obj) === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n\n    var sortedKeys = [],\n        _key;\n\n    for (_key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(_key)) {\n        sortedKeys.push(_key);\n      }\n    }\n\n    sortedKeys.sort();\n\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      _key = sortedKeys[i];\n      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n\n  return canonicalizedObj;\n}\n\nvar arrayDiff = new Diff();\n\narrayDiff.tokenize = function (value) {\n  return value.slice();\n};\n\narrayDiff.join = arrayDiff.removeEmpty = function (value) {\n  return value;\n};\n\nfunction diffArrays(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n\nfunction parsePatch(uniDiff) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    var index = {};\n    list.push(index); // Parse diff metadata\n\n    while (i < diffstr.length) {\n      var line = diffstr[i]; // File header found, end parsing diff metadata\n\n      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n        break;\n      } // Diff index\n\n\n      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    } // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n\n\n    parseFileHeader(index);\n    parseFileHeader(index); // Parse hunks\n\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      var _line = diffstr[i];\n\n      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n        break;\n      } else if (/^@@/.test(_line)) {\n        index.hunks.push(parseHunk());\n      } else if (_line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n      } else {\n        i++;\n      }\n    }\n  } // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n\n\n  function parseFileHeader(index) {\n    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n    if (fileHeader) {\n      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      var data = fileHeader[2].split('\\t', 2);\n      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n      if (/^\".*\"$/.test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n      i++;\n    }\n  } // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n\n\n  function parseHunk() {\n    var chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n    var hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: [],\n      linedelimiters: []\n    }; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n\n    var addCount = 0,\n        removeCount = 0;\n\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n        break;\n      }\n\n      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    } // Handle the empty block count case\n\n\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    } // Perform optional sanity checking\n\n\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}\n\n// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nfunction distanceIterator (start, minLine, maxLine) {\n  var wantForward = true,\n      backwardExhausted = false,\n      forwardExhausted = false,\n      localOffset = 1;\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      } // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n\n\n      if (start + localOffset <= maxLine) {\n        return localOffset;\n      }\n\n      forwardExhausted = true;\n    }\n\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      } // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n\n\n      if (minLine <= start - localOffset) {\n        return -localOffset++;\n      }\n\n      backwardExhausted = true;\n      return iterator();\n    } // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n\n  };\n}\n\nfunction applyPatch(source, uniDiff) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  } // Apply the diff to the input\n\n\n  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\n    return line === patchContent;\n  },\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n      removeEOFNL,\n      addEOFNL;\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n\n\n  function hunkFits(hunk, toPos) {\n    for (var j = 0; j < hunk.lines.length; j++) {\n      var line = hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line;\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n\n        toPos++;\n      }\n    }\n\n    return true;\n  } // Search best fit offsets for each hunk based on the previous ones\n\n\n  for (var i = 0; i < hunks.length; i++) {\n    var hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n    var iterator = distanceIterator(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    } // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n\n\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  } // Apply patch hunks\n\n\n  var diffOffset = 0;\n\n  for (var _i = 0; _i < hunks.length; _i++) {\n    var _hunk = hunks[_i],\n        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\n    diffOffset += _hunk.newLines - _hunk.oldLines;\n\n    for (var j = 0; j < _hunk.lines.length; j++) {\n      var line = _hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line,\n          delimiter = _hunk.linedelimiters[j];\n\n      if (operation === ' ') {\n        _toPos++;\n      } else if (operation === '-') {\n        lines.splice(_toPos, 1);\n        delimiters.splice(_toPos, 1);\n        /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(_toPos, 0, content);\n        delimiters.splice(_toPos, 0, delimiter);\n        _toPos++;\n      } else if (operation === '\\\\') {\n        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  } // Handle EOFNL insertion/removal\n\n\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n\n  for (var _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n\n  return lines.join('');\n} // Wrapper that supports multiple file patches via callbacks.\n\nfunction applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  var currentIndex = 0;\n\n  function processIndex() {\n    var index = uniDiff[currentIndex++];\n\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function (err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      var updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function (err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n\n  processIndex();\n}\n\nfunction structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n\n  var diff = diffLines(oldStr, newStr, options);\n\n  if (!diff) {\n    return;\n  }\n\n  diff.push({\n    value: '',\n    lines: []\n  }); // Append an empty value to make cleanup easier\n\n  function contextLines(lines) {\n    return lines.map(function (entry) {\n      return ' ' + entry;\n    });\n  }\n\n  var hunks = [];\n  var oldRangeStart = 0,\n      newRangeStart = 0,\n      curRange = [],\n      oldLine = 1,\n      newLine = 1;\n\n  var _loop = function _loop(i) {\n    var current = diff[i],\n        lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n    current.lines = lines;\n\n    if (current.added || current.removed) {\n      var _curRange;\n\n      // If we have previous context, start with that\n      if (!oldRangeStart) {\n        var prev = diff[i - 1];\n        oldRangeStart = oldLine;\n        newRangeStart = newLine;\n\n        if (prev) {\n          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n          oldRangeStart -= curRange.length;\n          newRangeStart -= curRange.length;\n        }\n      } // Output our changes\n\n\n      (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {\n        return (current.added ? '+' : '-') + entry;\n      }))); // Track the updated file position\n\n\n      if (current.added) {\n        newLine += lines.length;\n      } else {\n        oldLine += lines.length;\n      }\n    } else {\n      // Identical context lines. Track line changes\n      if (oldRangeStart) {\n        // Close out any changes that have been output (or join overlapping)\n        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n          var _curRange2;\n\n          // Overlapping\n          (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n        } else {\n          var _curRange3;\n\n          // end the range and output\n          var contextSize = Math.min(lines.length, options.context);\n\n          (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n\n          var hunk = {\n            oldStart: oldRangeStart,\n            oldLines: oldLine - oldRangeStart + contextSize,\n            newStart: newRangeStart,\n            newLines: newLine - newRangeStart + contextSize,\n            lines: curRange\n          };\n\n          if (i >= diff.length - 2 && lines.length <= options.context) {\n            // EOF is inside this hunk\n            var oldEOFNewline = /\\n$/.test(oldStr);\n            var newEOFNewline = /\\n$/.test(newStr);\n            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n\n            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n              // special case: old has no eol and no trailing context; no-nl can end up before adds\n              // however, if the old file is empty, do not output the no-nl line\n              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n            }\n\n            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n              curRange.push('\\\\ No newline at end of file');\n            }\n          }\n\n          hunks.push(hunk);\n          oldRangeStart = 0;\n          newRangeStart = 0;\n          curRange = [];\n        }\n      }\n\n      oldLine += lines.length;\n      newLine += lines.length;\n    }\n  };\n\n  for (var i = 0; i < diff.length; i++) {\n    _loop(i);\n  }\n\n  return {\n    oldFileName: oldFileName,\n    newFileName: newFileName,\n    oldHeader: oldHeader,\n    newHeader: newHeader,\n    hunks: hunks\n  };\n}\nfunction formatPatch(diff) {\n  var ret = [];\n\n  if (diff.oldFileName == diff.newFileName) {\n    ret.push('Index: ' + diff.oldFileName);\n  }\n\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (var i = 0; i < diff.hunks.length; i++) {\n    var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n\n    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\nfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n}\nfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n\nfunction arrayEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  return arrayStartsWith(a, b);\n}\nfunction arrayStartsWith(array, start) {\n  if (start.length > array.length) {\n    return false;\n  }\n\n  for (var i = 0; i < start.length; i++) {\n    if (start[i] !== array[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction calcLineCount(hunk) {\n  var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\n      oldLines = _calcOldNewLineCount.oldLines,\n      newLines = _calcOldNewLineCount.newLines;\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\nfunction merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n  var mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    var mineCurrent = mine.hunks[mineIndex] || {\n      oldStart: Infinity\n    },\n        theirsCurrent = theirs.hunks[theirsIndex] || {\n      oldStart: Infinity\n    };\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      var mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n      return parsePatch(param)[0];\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n\n    return structuredPatch(undefined, undefined, base, param);\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {\n      mine: mine,\n      theirs: theirs\n    };\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart,\n    oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset,\n    newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  var mine = {\n    offset: mineOffset,\n    lines: mineLines,\n    index: 0\n  },\n      their = {\n    offset: theirOffset,\n    lines: theirLines,\n    index: 0\n  }; // Handle any leading content\n\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    var mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      var _hunk$lines;\n\n      // Mine inserted\n      (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      var _hunk$lines2;\n\n      // Theirs inserted\n      (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  } // Now push anything that may be remaining\n\n\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      var _hunk$lines3;\n\n      (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n\n      return;\n    } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      var _hunk$lines4;\n\n      (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n\n      return;\n    }\n  } else if (arrayEqual(myChanges, theirChanges)) {\n    var _hunk$lines5;\n\n    (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n\n  if (theirChanges.merged) {\n    var _hunk$lines6;\n\n    (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\n\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  var ret = [],\n      operation = state.lines[state.index][0];\n\n  while (state.index < state.lines.length) {\n    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\n\nfunction collectContext(state, matchChanges) {\n  var changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n\n  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n    var change = state.lines[state.index],\n        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n    merged.push(match);\n    matchIndex++; // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged: merged,\n    changes: changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function (prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\n\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (var i = 0; i < delta; i++) {\n    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  var oldLines = 0;\n  var newLines = 0;\n  lines.forEach(function (line) {\n    if (typeof line !== 'string') {\n      var myCount = calcOldNewLineCount(line.mine);\n      var theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n  return {\n    oldLines: oldLines,\n    newLines: newLines\n  };\n}\n\n// See: http://code.google.com/p/google-diff-match-patch/wiki/API\nfunction convertChangesToDMP(changes) {\n  var ret = [],\n      change,\n      operation;\n\n  for (var i = 0; i < changes.length; i++) {\n    change = changes[i];\n\n    if (change.added) {\n      operation = 1;\n    } else if (change.removed) {\n      operation = -1;\n    } else {\n      operation = 0;\n    }\n\n    ret.push([operation, change.value]);\n  }\n\n  return ret;\n}\n\nfunction convertChangesToXML(changes) {\n  var ret = [];\n\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n\n    if (change.added) {\n      ret.push('<ins>');\n    } else if (change.removed) {\n      ret.push('<del>');\n    }\n\n    ret.push(escapeHTML(change.value));\n\n    if (change.added) {\n      ret.push('</ins>');\n    } else if (change.removed) {\n      ret.push('</del>');\n    }\n  }\n\n  return ret.join('');\n}\n\nfunction escapeHTML(s) {\n  var n = s;\n  n = n.replace(/&/g, '&amp;');\n  n = n.replace(/</g, '&lt;');\n  n = n.replace(/>/g, '&gt;');\n  n = n.replace(/\"/g, '&quot;');\n  return n;\n}\n\nexport { Diff, applyPatch, applyPatches, canonicalize, convertChangesToDMP, convertChangesToXML, createPatch, createTwoFilesPatch, diffArrays, diffChars, diffCss, diffJson, diffLines, diffSentences, diffTrimmedLines, diffWords, diffWordsWithSpace, merge, parsePatch, structuredPatch };\n"],"names":["t","e","this","seed","Math","imul","random","s","i","n","type","ops","c","length","push","o","l","increment","rx","ry","h","r","f","disableMultiStroke","concat","estimatedPoints","opset","sqrt","PI","pow","max","curveStepCount","abs","curveFitting","a","randomizer","next","roughness","disableMultiStrokeFill","u","maxRandomnessOffset","g","d","p","bowing","_","m","w","v","op","data","curveTightness","cos","sin","stroke","strokeWidth","fillStyle","fillWeight","hachureAngle","hachureGap","dashOffset","dashGap","zigzagOffset","combineNestedSvgPaths","padding","Array","isArray","animate","iterations","rtl","y","x","brackets","floor","trim","setAttribute","document","createElementNS","color","getTotalLength","appendChild","style","strokeDashoffset","strokeDasharray","animation","_state","_resizing","_seed","_lastSizes","_animationDelay","_resizeListener","setTimeout","haveRectsChanged","show","_e","_config","JSON","parse","stringify","attach","animationDuration","refresh","parentElement","window","__rno_kf_s","createElement","textContent","head","_svg","position","top","left","overflow","pointerEvents","width","height","insertAdjacentElement","getComputedStyle","attachListeners","removeEventListener","_ro","unobserve","detachListeners","addEventListener","passive","ResizeObserver","contentRect","observe","rects","isSameRect","round","isShowing","pendingRefresh","Promise","resolve","then","hide","render","lastChild","removeChild","forEach","multiline","getClientRects","svgRect","getBoundingClientRect","Diff","buildValues","diff","components","newString","oldString","useLongestToken","componentPos","componentLen","newPos","oldPos","component","removed","value","join","slice","count","added","tmp","map","oldValue","lastComponent","equals","pop","clonePath","path","prototype","options","arguments","undefined","callback","self","done","castInput","removeEmpty","tokenize","newLen","oldLen","editLength","maxEditLength","min","bestPath","extractCommon","execEditLength","diagonalPath","basePath","addPath","removePath","_oldPos","canAdd","canRemove","pushComponent","exec","ret","last","commonCount","right","comparator","ignoreCase","toLowerCase","array","split","chars","generateOptions","defaults","name","hasOwnProperty","extendedWordChars","reWhitespace","wordDiff","diffWords","oldStr","newStr","ignoreWhitespace","test","tokens","splice","lineDiff","retLines","linesAndNewlines","line","newlineIsToken","sentenceDiff","cssDiff","_typeof","obj","Symbol","iterator","constructor","objectPrototypeToString","Object","toString","jsonDiff","canonicalize","stack","replacementStack","replacer","key","canonicalizedObj","call","toJSON","_key","sortedKeys","sort","_this$options","undefinedReplacement","_this$options$stringi","stringifyReplacer","k","replace","arrayDiff"],"sourceRoot":""}